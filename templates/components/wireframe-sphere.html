<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Wireframe Sphere</title>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ["Inter", "sans-serif"],
            },
            colors: {
              sky: {
                300: "#7dd3fc",
              },
              gray: {
                300: "#d1d5db",
              },
            },
          },
        },
      };
    </script>
  </head>
  <body class="font-sans bg-black text-white">
    <section class="relative w-full h-screen overflow-hidden">
      <!-- Three.js Canvas Container -->
      <div
        id="sphereContainer"
        class="absolute inset-0 w-full h-full z-0"
      ></div>

      <!-- Gradient Overlay -->
      <div
        class="absolute inset-0 bg-linear-to-t from-black via-black/70 to-transparent z-10"
      ></div>

      <!-- Content -->
      <div
        class="relative z-20 flex flex-col items-center justify-end h-full pb-20 md:pb-32 text-center"
      >
        <div class="max-w-3xl px-4">
          <h1 class="text-sm font-mono tracking-widest text-white/60 uppercase">
            Observation Log: Anomaly 7
          </h1>
          <p class="mt-4 text-3xl md:text-5xl font-bold leading-tight">
            Matter in a state of constant, beautiful flux.
          </p>
          <p
            class="mt-6 max-w-xl mx-auto text-base leading-relaxed text-gray-300/80"
          >
            A new form of digital existence has been observed. It responds to
            stimuli, changes form, and exudes an unknown energy. Further study
            is required.
          </p>
        </div>
      </div>
    </section>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- GSAP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>

    <script>
      const container = document.getElementById("sphereContainer");

      // Scene setup
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
      );
      camera.position.z = 3;

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);

      // Icosahedron geometry with custom shader
      const geometry = new THREE.IcosahedronGeometry(1.2, 64);

      const vertexShader = `
      uniform float time;
      varying vec3 vNormal;
      varying vec3 vPosition;

      // Simplex noise functions
      vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
      vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

      float snoise(vec3 v) {
        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
        vec3 i = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min(g.xyz, l.zxy);
        vec3 i2 = max(g.xyz, l.zxy);
        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;
        i = mod289(i);
        vec4 p = permute(permute(permute(
                    i.z + vec4(0.0, i1.z, i2.z, 1.0))
                + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                + i.x + vec4(0.0, i1.x, i2.x, 1.0));
        float n_ = 0.142857142857;
        vec3 ns = n_ * D.wyz - D.xzx;
        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_);
        vec4 x = x_ * ns.x + ns.yyyy;
        vec4 y = y_ * ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);
        vec4 b0 = vec4(x.xy, y.xy);
        vec4 b1 = vec4(x.zw, y.zw);
        vec4 s0 = floor(b0) * 2.0 + 1.0;
        vec4 s1 = floor(b1) * 2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));
        vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
        vec3 p0 = vec3(a0.xy, h.x);
        vec3 p1 = vec3(a0.zw, h.y);
        vec3 p2 = vec3(a1.xy, h.z);
        vec3 p3 = vec3(a1.zw, h.w);
        vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
        p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
        vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
        m = m * m;
        return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
      }

      void main() {
        vNormal = normal;
        vPosition = position;
        float displacement = snoise(position * 2.0 + time * 0.5) * 0.2;
        vec3 newPosition = position + normal * displacement;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
      }
    `;

      const fragmentShader = `
      uniform vec3 color;
      uniform vec3 pointLightPosition;
      varying vec3 vNormal;
      varying vec3 vPosition;

      void main() {
        vec3 normal = normalize(vNormal);
        vec3 lightDir = normalize(pointLightPosition - vPosition);
        float diffuse = max(dot(normal, lightDir), 0.0);

        // Fresnel effect for the glow
        float fresnel = 1.0 - dot(normal, vec3(0.0, 0.0, 1.0));
        fresnel = pow(fresnel, 2.0);

        vec3 finalColor = color * diffuse + color * fresnel * 0.5;

        gl_FragColor = vec4(finalColor, 1.0);
      }
    `;

      const material = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          pointLightPosition: { value: new THREE.Vector3(0, 0, 5) },
          color: { value: new THREE.Color("#ffffff") },
        },
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        wireframe: true,
      });

      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      // Point light
      const pointLight = new THREE.PointLight(0xffffff, 1, 100);
      pointLight.position.set(0, 0, 5);
      scene.add(pointLight);

      // Animation
      function animate(t) {
        requestAnimationFrame(animate);
        material.uniforms.time.value = t * 0.0003;
        mesh.rotation.y += 0.0005;
        mesh.rotation.x += 0.0002;
        renderer.render(scene, camera);
      }
      animate(0);

      // Handle resize
      window.addEventListener("resize", () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });

      // Mouse interaction
      window.addEventListener("mousemove", (e) => {
        const x = (e.clientX / window.innerWidth) * 2 - 1;
        const y = -(e.clientY / window.innerHeight) * 2 + 1;
        const vec = new THREE.Vector3(x, y, 0.5).unproject(camera);
        const dir = vec.sub(camera.position).normalize();
        const dist = -camera.position.z / dir.z;
        const pos = camera.position.clone().add(dir.multiplyScalar(dist));
        pointLight.position.copy(pos);
        material.uniforms.pointLightPosition.value = pos;
      });

      // GSAP entrance animations
      gsap.from("h1", {
        opacity: 0,
        y: 20,
        duration: 1,
        delay: 0.3,
        ease: "power3.out",
      });
      gsap.from("p", {
        opacity: 0,
        y: 20,
        duration: 1,
        delay: 0.5,
        stagger: 0.2,
        ease: "power3.out",
      });
    </script>
  </body>
</html>
