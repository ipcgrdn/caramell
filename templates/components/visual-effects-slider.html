<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Visual Effects Slider</title>

    <!-- Fonts -->
    <link
      rel="stylesheet"
      href="https://fonts.cdnfonts.com/css/pp-neue-montreal"
    />

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              mono: ["PPSupplyMono", "monospace"],
              sans: ["PP Neue Montreal", "sans-serif"],
            },
          },
        },
      };
    </script>

    <style>
      @font-face {
        font-family: "PPSupplyMono";
        src: url("https://assets.codepen.io/7558/PPSupplyMono-Regular.ttf")
          format("truetype");
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }

      :root {
        --font-mono: "PPSupplyMono", monospace;
        --font-sans: "PP Neue Montreal", sans-serif;
        --color-bg: #000;
        --color-text: #fff;
        --color-text-muted: rgba(255, 255, 255, 0.8);
        --color-text-light: rgba(255, 255, 255, 0.6);
        --color-accent: #fff;
        --font-size-mono: clamp(10px, 1.2vw, 12px);
        --spacing-sm: 1rem;
        --spacing-md: 2rem;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: var(--font-sans);
        background: var(--color-bg);
        overflow: hidden;
        color: var(--color-text);
        cursor: pointer;
      }

      .slider-wrapper {
        position: relative;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }

      .webgl-canvas {
        display: block;
        width: 100%;
        height: 100%;
      }

      .slide-number {
        position: absolute;
        top: 50%;
        left: var(--spacing-md);
        transform: translateY(-50%);
        font-family: var(--font-mono);
        font-size: 12px;
        font-weight: 600;
        color: var(--color-text);
        z-index: 3;
        letter-spacing: 1px;
        text-transform: uppercase;
      }

      .slide-total {
        position: absolute;
        top: 50%;
        right: var(--spacing-md);
        transform: translateY(-50%);
        font-family: var(--font-mono);
        font-size: 12px;
        font-weight: 600;
        color: var(--color-text);
        z-index: 3;
        letter-spacing: 1px;
        text-transform: uppercase;
      }

      .slides-navigation {
        position: absolute;
        bottom: var(--spacing-md);
        left: var(--spacing-md);
        right: var(--spacing-md);
        display: flex;
        gap: 0;
        z-index: 3;
        pointer-events: all;
      }

      .slide-nav-item {
        display: flex;
        flex-direction: column;
        cursor: pointer;
        padding: var(--spacing-sm);
        flex: 1;
        border: none;
        background: none;
      }

      .slide-progress-line {
        width: 100%;
        height: 2px;
        background: rgba(255, 255, 255, 0.2);
        margin-bottom: 8px;
        border-radius: 1px;
        overflow: hidden;
      }

      .slide-progress-fill {
        height: 100%;
        width: 0%;
        background: var(--color-accent);
        transition: width 0.1s ease, opacity 0.3s ease;
        border-radius: 1px;
      }

      .slide-nav-title {
        font-family: var(--font-mono);
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: var(--color-text-muted);
        font-weight: 600;
        transition: color 0.3s ease;
      }

      .slide-nav-item.active .slide-nav-title {
        color: var(--color-text);
      }

      .help-text {
        position: absolute;
        top: var(--spacing-md);
        left: var(--spacing-md);
        font-family: var(--font-mono);
        font-size: 11px;
        text-transform: uppercase;
        color: var(--color-text-muted);
        z-index: 3;
      }

      .tp-dfwv {
        position: fixed !important;
        top: 20px !important;
        right: 20px !important;
        z-index: 1000 !important;
        max-width: 320px !important;
        background: rgba(0, 0, 0, 0.9) !important;
        backdrop-filter: blur(20px) !important;
        border: 1px solid rgba(255, 255, 255, 0.1) !important;
        border-radius: 8px !important;
      }

      .tp-dfwv .tp-btnv_b {
        background: rgba(255, 255, 255, 0.1) !important;
        border: 1px solid rgba(255, 255, 255, 0.2) !important;
        color: #ffffff !important;
        font-family: var(--font-mono) !important;
        border-radius: 4px !important;
      }

      .tp-dfwv .tp-btnv_b:hover {
        background: rgba(255, 255, 255, 0.2) !important;
      }

      @media (max-width: 600px) {
        .slides-navigation {
          bottom: var(--spacing-sm);
          left: var(--spacing-sm);
          right: var(--spacing-sm);
        }

        .slide-nav-item {
          padding: 0.75rem;
        }

        .help-text {
          top: var(--spacing-sm);
          left: var(--spacing-sm);
        }

        .slide-number {
          left: var(--spacing-sm);
        }

        .slide-total {
          right: var(--spacing-sm);
        }

        .tp-dfwv {
          top: 10px !important;
          right: 10px !important;
          max-width: 280px !important;
        }
      }

      .slider-wrapper {
        opacity: 0;
        transition: opacity 1.5s ease-in;
        pointer-events: none;
      }

      .slider-wrapper.loaded {
        opacity: 1;
        pointer-events: auto;
      }
    </style>
  </head>
  <body>
    <main class="slider-wrapper">
      <canvas class="webgl-canvas"></canvas>
      <span class="slide-number" id="slideNumber">01</span>
      <span class="slide-total" id="slideTotal">06</span>
      <span class="help-text">
        H: Toggle Settings | Space/Arrow: Navigate | Click to Advance
      </span>
      <nav class="slides-navigation" id="slidesNav"></nav>
    </main>

    <script type="importmap">
      {
        "imports": {
          "three": "https://esm.sh/three"
        }
      }
    </script>

    <script type="module">
      // ========================================
      // PRELOADER
      // ========================================
      class SliderLoadingManager {
        constructor() {
          this.overlay = null;
          this.canvas = null;
          this.ctx = null;
          this.animationId = null;
          this.startTime = null;
          this.duration = 3000;
          this.createLoadingScreen();
        }

        createLoadingScreen() {
          this.overlay = document.createElement("div");
          this.overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
          `;

          this.canvas = document.createElement("canvas");
          this.canvas.width = 300;
          this.canvas.height = 300;

          this.ctx = this.canvas.getContext("2d");
          this.overlay.appendChild(this.canvas);
          document.body.appendChild(this.overlay);

          this.startAnimation();
        }

        startAnimation() {
          const centerX = this.canvas.width / 2;
          const centerY = this.canvas.height / 2;
          let time = 0;
          let lastTime = 0;

          const dotRings = [
            { radius: 20, count: 8 },
            { radius: 35, count: 12 },
            { radius: 50, count: 16 },
            { radius: 65, count: 20 },
            { radius: 80, count: 24 },
          ];

          const colors = {
            primary: "#ffffff",
            accent: "#dddddd",
          };

          const easeInOutSine = (t) => {
            return -(Math.cos(Math.PI * t) - 1) / 2;
          };

          const easeInOutCubic = (t) => {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
          };

          const smoothstep = (edge0, edge1, x) => {
            const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
            return t * t * (3 - 2 * t);
          };

          const hexToRgb = (hex) => {
            if (hex.startsWith("#")) {
              return [
                parseInt(hex.slice(1, 3), 16),
                parseInt(hex.slice(3, 5), 16),
                parseInt(hex.slice(5, 7), 16),
              ];
            }
            const match = hex.match(/\d+/g);
            return match
              ? [parseInt(match[0]), parseInt(match[1]), parseInt(match[2])]
              : [255, 255, 255];
          };

          const interpolateColor = (color1, color2, t, opacity = 1) => {
            const rgb1 = hexToRgb(color1);
            const rgb2 = hexToRgb(color2);
            const r = Math.round(rgb1[0] + (rgb2[0] - rgb1[0]) * t);
            const g = Math.round(rgb1[1] + (rgb2[1] - rgb1[1]) * t);
            const b = Math.round(rgb1[2] + (rgb2[2] - rgb1[2]) * t);
            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
          };

          const animate = (timestamp) => {
            if (!this.startTime) this.startTime = timestamp;

            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            time += deltaTime * 0.001;

            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            this.ctx.beginPath();
            this.ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
            const rgb = hexToRgb(colors.primary);
            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.9)`;
            this.ctx.fill();

            dotRings.forEach((ring, ringIndex) => {
              for (let i = 0; i < ring.count; i++) {
                const angle = (i / ring.count) * Math.PI * 2;
                const pulseTime = time * 2 - ringIndex * 0.4;
                const radiusPulse =
                  easeInOutSine((Math.sin(pulseTime) + 1) / 2) * 6 - 3;
                const x =
                  centerX + Math.cos(angle) * (ring.radius + radiusPulse);
                const y =
                  centerY + Math.sin(angle) * (ring.radius + radiusPulse);

                const opacityPhase = (Math.sin(pulseTime + i * 0.2) + 1) / 2;
                const opacityBase = 0.3 + easeInOutSine(opacityPhase) * 0.7;
                const highlightPhase = (Math.sin(pulseTime) + 1) / 2;
                const highlightIntensity = easeInOutCubic(highlightPhase);

                this.ctx.beginPath();
                this.ctx.arc(x, y, 2, 0, Math.PI * 2);
                const colorBlend = smoothstep(0.2, 0.8, highlightIntensity);
                this.ctx.fillStyle = interpolateColor(
                  colors.primary,
                  colors.accent,
                  colorBlend,
                  opacityBase
                );
                this.ctx.fill();
              }
            });

            if (timestamp - this.startTime >= this.duration) {
              this.complete();
              return;
            }

            this.animationId = requestAnimationFrame(animate);
          };

          this.animationId = requestAnimationFrame(animate);
        }

        complete() {
          if (this.animationId) {
            cancelAnimationFrame(this.animationId);
          }

          if (this.overlay) {
            this.overlay.style.opacity = "0";
            this.overlay.style.transition = "opacity 0.8s ease";
            setTimeout(() => {
              this.overlay?.remove();

              setTimeout(() => {
                const sliderWrapper = document.querySelector(".slider-wrapper");
                if (sliderWrapper) {
                  sliderWrapper.classList.add("loaded");
                }
              }, 500);
            }, 800);
          }
        }
      }

      // Initialize preloader
      const loadingManager = new SliderLoadingManager();

      // ========================================
      // VISUAL EFFECTS SLIDER CONFIGURATION
      // ========================================
      const SLIDER_CONFIG = {
        settings: {
          transitionDuration: 2.5,
          autoSlideSpeed: 5000,
          currentEffect: "glass",
          currentEffectPreset: "Default",
          globalIntensity: 1.0,
          speedMultiplier: 1.0,
          distortionStrength: 1.0,
          colorEnhancement: 1.0,
          glassRefractionStrength: 1.0,
          glassChromaticAberration: 1.0,
          glassBubbleClarity: 1.0,
          glassEdgeGlow: 1.0,
          glassLiquidFlow: 1.0,
          frostIntensity: 1.5,
          frostCrystalSize: 1.0,
          frostIceCoverage: 1.0,
          frostTemperature: 1.0,
          frostTexture: 1.0,
          rippleFrequency: 25.0,
          rippleAmplitude: 0.08,
          rippleWaveSpeed: 1.0,
          rippleRippleCount: 1.0,
          rippleDecay: 1.0,
          plasmaIntensity: 1.2,
          plasmaSpeed: 0.8,
          plasmaEnergyIntensity: 0.4,
          plasmaContrastBoost: 0.3,
          plasmaTurbulence: 1.0,
          timeshiftDistortion: 1.6,
          timeshiftBlur: 1.5,
          timeshiftFlow: 1.4,
          timeshiftChromatic: 1.5,
          timeshiftTurbulence: 1.4,
        },
        effectPresets: {
          glass: {
            Subtle: {
              glassRefractionStrength: 0.6,
              glassChromaticAberration: 0.5,
              glassBubbleClarity: 1.3,
              glassEdgeGlow: 0.7,
              glassLiquidFlow: 0.8,
            },
            Default: {
              glassRefractionStrength: 1.0,
              glassChromaticAberration: 1.0,
              glassBubbleClarity: 1.0,
              glassEdgeGlow: 1.0,
              glassLiquidFlow: 1.0,
            },
            Crystal: {
              glassRefractionStrength: 1.5,
              glassChromaticAberration: 1.8,
              glassBubbleClarity: 0.7,
              glassEdgeGlow: 1.4,
              glassLiquidFlow: 0.5,
            },
            Liquid: {
              glassRefractionStrength: 0.8,
              glassChromaticAberration: 0.4,
              glassBubbleClarity: 1.2,
              glassEdgeGlow: 0.8,
              glassLiquidFlow: 1.8,
            },
          },
          frost: {
            Light: {
              frostIntensity: 0.8,
              frostCrystalSize: 1.3,
              frostIceCoverage: 0.6,
              frostTemperature: 0.7,
              frostTexture: 0.8,
            },
            Default: {
              frostIntensity: 1.5,
              frostCrystalSize: 1.0,
              frostIceCoverage: 1.0,
              frostTemperature: 1.0,
              frostTexture: 1.0,
            },
            Heavy: {
              frostIntensity: 2.2,
              frostCrystalSize: 0.7,
              frostIceCoverage: 1.4,
              frostTemperature: 1.5,
              frostTexture: 1.3,
            },
            Arctic: {
              frostIntensity: 2.8,
              frostCrystalSize: 0.5,
              frostIceCoverage: 1.8,
              frostTemperature: 2.0,
              frostTexture: 1.6,
            },
          },
          ripple: {
            Gentle: {
              rippleFrequency: 15.0,
              rippleAmplitude: 0.05,
              rippleWaveSpeed: 0.7,
              rippleRippleCount: 0.8,
              rippleDecay: 1.2,
            },
            Default: {
              rippleFrequency: 25.0,
              rippleAmplitude: 0.08,
              rippleWaveSpeed: 1.0,
              rippleRippleCount: 1.0,
              rippleDecay: 1.0,
            },
            Strong: {
              rippleFrequency: 35.0,
              rippleAmplitude: 0.12,
              rippleWaveSpeed: 1.4,
              rippleRippleCount: 1.3,
              rippleDecay: 0.8,
            },
            Tsunami: {
              rippleFrequency: 45.0,
              rippleAmplitude: 0.18,
              rippleWaveSpeed: 1.8,
              rippleRippleCount: 1.6,
              rippleDecay: 0.6,
            },
          },
          plasma: {
            Calm: {
              plasmaIntensity: 0.8,
              plasmaSpeed: 0.5,
              plasmaEnergyIntensity: 0.2,
              plasmaContrastBoost: 0.1,
              plasmaTurbulence: 0.6,
            },
            Default: {
              plasmaIntensity: 1.2,
              plasmaSpeed: 0.8,
              plasmaEnergyIntensity: 0.4,
              plasmaContrastBoost: 0.3,
              plasmaTurbulence: 1.0,
            },
            Storm: {
              plasmaIntensity: 1.8,
              plasmaSpeed: 1.3,
              plasmaEnergyIntensity: 0.7,
              plasmaContrastBoost: 0.5,
              plasmaTurbulence: 1.5,
            },
            Nuclear: {
              plasmaIntensity: 2.5,
              plasmaSpeed: 1.8,
              plasmaEnergyIntensity: 1.0,
              plasmaContrastBoost: 0.8,
              plasmaTurbulence: 2.0,
            },
          },
          timeshift: {
            Subtle: {
              timeshiftDistortion: 0.5,
              timeshiftBlur: 0.6,
              timeshiftFlow: 0.5,
              timeshiftChromatic: 0.4,
              timeshiftTurbulence: 0.6,
            },
            Default: {
              timeshiftDistortion: 1.6,
              timeshiftBlur: 1.5,
              timeshiftFlow: 1.4,
              timeshiftChromatic: 1.5,
              timeshiftTurbulence: 1.4,
            },
            Intense: {
              timeshiftDistortion: 2.2,
              timeshiftBlur: 2.0,
              timeshiftFlow: 2.0,
              timeshiftChromatic: 2.2,
              timeshiftTurbulence: 2.0,
            },
            Dreamlike: {
              timeshiftDistortion: 2.8,
              timeshiftBlur: 2.5,
              timeshiftFlow: 2.5,
              timeshiftChromatic: 2.6,
              timeshiftTurbulence: 2.5,
            },
          },
        },
      };

      // ========================================
      // MAIN SLIDER CODE
      // ========================================
      import * as THREE from "three";
      import { Pane } from "https://cdn.skypack.dev/tweakpane@4.0.4";

      let currentSlideIndex = 0;
      let isTransitioning = false;
      let shaderMaterial, renderer, scene, camera;
      let slideTextures = [];
      let texturesLoaded = false;
      let autoSlideTimer = null;
      let progressAnimation = null;
      let sliderEnabled = false;
      let pane = null;
      let isApplyingPreset = false;
      let effectFolders = {};

      const SLIDE_DURATION = () => SLIDER_CONFIG.settings.autoSlideSpeed;
      const PROGRESS_UPDATE_INTERVAL = 50;
      const TRANSITION_DURATION = () =>
        SLIDER_CONFIG.settings.transitionDuration;

      const slides = [
        {
          title: "Ethereal Glow",
          media: "https://assets.codepen.io/7558/orange-portrait-001.jpg",
        },
        {
          title: "Rose Mirage",
          media: "https://assets.codepen.io/7558/orange-portrait-002.jpg",
        },
        {
          title: "Velvet Mystique",
          media: "https://assets.codepen.io/7558/orange-portrait-003.jpg",
        },
        {
          title: "Golden Hour",
          media: "https://assets.codepen.io/7558/orange-portrait-004.jpg",
        },
        {
          title: "Midnight Dreams",
          media: "https://assets.codepen.io/7558/orange-portrait-005.jpg",
        },
        {
          title: "Silver Light",
          media: "https://assets.codepen.io/7558/orange-portrait-006.jpg",
        },
      ];

      let touchStartX = 0;
      let touchEndX = 0;

      const vertexShader = `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `;

      const fragmentShader = `
        uniform sampler2D uTexture1;
        uniform sampler2D uTexture2;
        uniform float uProgress;
        uniform vec2 uResolution;
        uniform vec2 uTexture1Size;
        uniform vec2 uTexture2Size;
        uniform int uEffectType;

        uniform float uGlobalIntensity;
        uniform float uSpeedMultiplier;
        uniform float uDistortionStrength;
        uniform float uColorEnhancement;

        uniform float uGlassRefractionStrength;
        uniform float uGlassChromaticAberration;
        uniform float uGlassBubbleClarity;
        uniform float uGlassEdgeGlow;
        uniform float uGlassLiquidFlow;

        uniform float uFrostIntensity;
        uniform float uFrostCrystalSize;
        uniform float uFrostIceCoverage;
        uniform float uFrostTemperature;
        uniform float uFrostTexture;

        uniform float uRippleFrequency;
        uniform float uRippleAmplitude;
        uniform float uRippleWaveSpeed;
        uniform float uRippleRippleCount;
        uniform float uRippleDecay;

        uniform float uPlasmaIntensity;
        uniform float uPlasmaSpeed;
        uniform float uPlasmaEnergyIntensity;
        uniform float uPlasmaContrastBoost;
        uniform float uPlasmaTurbulence;

        uniform float uTimeshiftDistortion;
        uniform float uTimeshiftBlur;
        uniform float uTimeshiftFlow;
        uniform float uTimeshiftChromatic;
        uniform float uTimeshiftTurbulence;

        varying vec2 vUv;

        vec2 getCoverUV(vec2 uv, vec2 textureSize) {
          vec2 s = uResolution / textureSize;
          float scale = max(s.x, s.y);
          vec2 scaledSize = textureSize * scale;
          vec2 offset = (uResolution - scaledSize) * 0.5;
          return (uv * uResolution - offset) / scaledSize;
        }

        float noise(vec2 p) {
          return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
        }

        float smoothNoise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          f = f * f * (3.0 - 2.0 * f);

          return mix(
            mix(noise(i), noise(i + vec2(1.0, 0.0)), f.x),
            mix(noise(i + vec2(0.0, 1.0)), noise(i + vec2(1.0, 1.0)), f.x),
            f.y
          );
        }

        float rand(vec2 uv) {
          float a = dot(uv, vec2(92., 80.));
          float b = dot(uv, vec2(41., 62.));
          float x = sin(a) + cos(b) * 51.;
          return fract(x);
        }

        vec4 glassEffect(vec2 uv, float progress) {
          float glassStrength = 0.08 * uGlassRefractionStrength * uDistortionStrength * uGlobalIntensity;
          float chromaticAberration = 0.02 * uGlassChromaticAberration * uGlobalIntensity;
          float waveDistortion = 0.025 * uDistortionStrength;
          float clearCenterSize = 0.3 * uGlassBubbleClarity;
          float surfaceRipples = 0.004 * uDistortionStrength;
          float liquidFlow = 0.015 * uGlassLiquidFlow * uSpeedMultiplier;
          float rimLightWidth = 0.05;
          float glassEdgeWidth = 0.025;

          float brightnessPhase = smoothstep(0.8, 1.0, progress);
          float rimLightIntensity = 0.08 * (1.0 - brightnessPhase) * uGlassEdgeGlow * uGlobalIntensity;
          float glassEdgeOpacity = 0.06 * (1.0 - brightnessPhase) * uGlassEdgeGlow;

          vec2 center = vec2(0.5, 0.5);
          vec2 p = uv * uResolution;

          vec2 uv1 = getCoverUV(uv, uTexture1Size);
          vec2 uv2_base = getCoverUV(uv, uTexture2Size);

          float maxRadius = length(uResolution) * 0.85;
          float bubbleRadius = progress * maxRadius;
          vec2 sphereCenter = center * uResolution;

          float dist = length(p - sphereCenter);
          float normalizedDist = dist / max(bubbleRadius, 0.001);
          vec2 direction = (dist > 0.0) ? (p - sphereCenter) / dist : vec2(0.0);
          float inside = smoothstep(bubbleRadius + 3.0, bubbleRadius - 3.0, dist);

          float distanceFactor = smoothstep(clearCenterSize, 1.0, normalizedDist);
          float time = progress * 5.0 * uSpeedMultiplier;

          vec2 liquidSurface = vec2(
            smoothNoise(uv * 100.0 + time * 0.3),
            smoothNoise(uv * 100.0 + time * 0.2 + 50.0)
          ) - 0.5;
          liquidSurface *= surfaceRipples * distanceFactor;

          vec2 distortedUV = uv2_base;
          if (inside > 0.0) {
            float refractionOffset = glassStrength * pow(distanceFactor, 1.5);
            vec2 flowDirection = normalize(direction + vec2(sin(time), cos(time * 0.7)) * 0.3);
            distortedUV -= flowDirection * refractionOffset;

            float wave1 = sin(normalizedDist * 22.0 - time * 3.5);
            float wave2 = sin(normalizedDist * 35.0 + time * 2.8) * 0.7;
            float wave3 = sin(normalizedDist * 50.0 - time * 4.2) * 0.5;
            float combinedWave = (wave1 + wave2 + wave3) / 3.0;

            float waveOffset = combinedWave * waveDistortion * distanceFactor;
            distortedUV -= direction * waveOffset + liquidSurface;

            vec2 flowOffset = vec2(
              sin(time + normalizedDist * 10.0),
              cos(time * 0.8 + normalizedDist * 8.0)
            ) * liquidFlow * distanceFactor * inside;
            distortedUV += flowOffset;
          }

          vec4 newImg;
          if (inside > 0.0) {
            float aberrationOffset = chromaticAberration * pow(distanceFactor, 1.2);

            vec2 uv_r = distortedUV + direction * aberrationOffset * 1.2;
            vec2 uv_g = distortedUV + direction * aberrationOffset * 0.2;
            vec2 uv_b = distortedUV - direction * aberrationOffset * 0.8;

            float r = texture2D(uTexture2, uv_r).r;
            float g = texture2D(uTexture2, uv_g).g;
            float b = texture2D(uTexture2, uv_b).b;
            newImg = vec4(r, g, b, 1.0);
          } else {
            newImg = texture2D(uTexture2, uv2_base);
          }

          if (inside > 0.0 && rimLightIntensity > 0.0) {
            float rim = smoothstep(1.0 - rimLightWidth, 1.0, normalizedDist) *
                        (1.0 - smoothstep(1.0, 1.01, normalizedDist));
            newImg.rgb += rim * rimLightIntensity;

            float edge = smoothstep(1.0 - glassEdgeWidth, 1.0, normalizedDist) *
                         (1.0 - smoothstep(1.0, 1.01, normalizedDist));
            newImg.rgb = mix(newImg.rgb, vec3(1.0), edge * glassEdgeOpacity);
          }

          newImg.rgb = mix(newImg.rgb, newImg.rgb * 1.2, (uColorEnhancement - 1.0) * 0.5);

          vec4 currentImg = texture2D(uTexture1, uv1);

          if (progress > 0.95) {
            vec4 pureNewImg = texture2D(uTexture2, uv2_base);
            float endTransition = (progress - 0.95) / 0.05;
            newImg = mix(newImg, pureNewImg, endTransition);
          }

          return mix(currentImg, newImg, inside);
        }

        vec4 frostEffect(vec2 uv, float progress) {
          vec4 currentImg = texture2D(uTexture1, getCoverUV(uv, uTexture1Size));
          vec4 newImg = texture2D(uTexture2, getCoverUV(uv, uTexture2Size));

          float effectiveIntensity = uFrostIntensity * uGlobalIntensity;
          float crystalScale = 80.0 / uFrostCrystalSize;
          float iceScale = 40.0 / uFrostCrystalSize;
          float temperatureEffect = uFrostTemperature;

          float frost1 = smoothNoise(uv * crystalScale * uFrostTexture);
          float frost2 = smoothNoise(uv * iceScale + 50.0) * 0.7;
          float frost3 = smoothNoise(uv * (crystalScale * 2.0) + 100.0) * 0.3;
          float frost = (frost1 + frost2 + frost3) / 2.0;

          float icespread = smoothNoise(uv * 25.0 / uFrostCrystalSize + 200.0);

          vec2 rnd = vec2(
            rand(uv + frost * 0.1),
            rand(uv + frost * 0.1 + 0.5)
          );

          float clampedIceCoverage = clamp(uFrostIceCoverage, 0.1, 2.5);
          float size = mix(progress, sqrt(progress), 0.5) * 1.12 * clampedIceCoverage + 0.0000001;

          float lensY = clamp(pow(size, clamp(4.0, 1.5, 6.0)) / 2.0, size * 0.1, size * 8.0);
          vec2 lens = vec2(size, lensY);

          float dist = distance(uv, vec2(0.5, 0.5));
          float vignette = pow(1.0 - smoothstep(lens.x, lens.y, dist), 2.0);

          float frostyness = 0.8 * effectiveIntensity * uDistortionStrength;
          rnd *= frost * vignette * frostyness * (1.0 - floor(vignette));

          vec4 regular = newImg;
          vec4 frozen = texture2D(uTexture2, getCoverUV(uv + rnd * 0.06, uTexture2Size));

          float tempShift = clamp(temperatureEffect * 0.15, 0.0, 0.3);
          frozen *= vec4(
            clamp(0.85 + tempShift, 0.7, 1.2),
            clamp(0.9, 0.8, 1.0),
            clamp(1.2 - tempShift, 0.8, 1.3),
            1.0
          );
          float tempMixStrength = clamp(0.1 * temperatureEffect, 0.0, 0.25);
          frozen = mix(frozen, vec4(0.9, 0.95, 1.1, 1.0), tempMixStrength);

          float frostMask = smoothstep(icespread * 0.8, 1.0, pow(vignette, 1.5));
          vec4 frostResult = mix(frozen, regular, frostMask);

          float transitionStart = mix(0.85, 0.7, clamp(effectiveIntensity - 1.0, 0.0, 1.0));
          float colorTransition = smoothstep(transitionStart, 1.0, progress);
          vec4 finalFrost = mix(frostResult, regular, colorTransition);

          finalFrost.rgb = mix(finalFrost.rgb, finalFrost.rgb * 1.2, (uColorEnhancement - 1.0) * 0.5);

          float overallBlend = smoothstep(0.0, 1.0, progress);

          if (progress > 0.95) {
            float endTransition = (progress - 0.95) / 0.05;
            finalFrost = mix(finalFrost, newImg, endTransition * 0.5);
          }

          return mix(currentImg, finalFrost, overallBlend);
        }

        vec4 rippleEffect(vec2 uv, float progress) {
          vec4 currentImg = texture2D(uTexture1, getCoverUV(uv, uTexture1Size));
          vec4 newImg = texture2D(uTexture2, getCoverUV(uv, uTexture2Size));

          vec2 center = vec2(0.5, 0.5);
          float dist = distance(uv, center);
          float maxDist = 0.8;

          float effectiveSpeed = uRippleWaveSpeed * uSpeedMultiplier;
          float effectiveAmplitude = uRippleAmplitude * uDistortionStrength * uGlobalIntensity;
          float effectiveDecay = uRippleDecay;

          float waveRadius = progress * maxDist * 1.5 * effectiveSpeed;

          float ripple1 = sin((dist - waveRadius) * uRippleFrequency) * exp(-abs(dist - waveRadius) * 8.0 * effectiveDecay);
          float ripple2 = sin((dist - waveRadius * 0.7) * uRippleFrequency * 1.3) *
                         exp(-abs(dist - waveRadius * 0.7) * 6.0 * effectiveDecay) * 0.6 * uRippleRippleCount;
          float ripple3 = sin((dist - waveRadius * 0.4) * uRippleFrequency * 1.8) *
                         exp(-abs(dist - waveRadius * 0.4) * 4.0 * effectiveDecay) * 0.3 * uRippleRippleCount;

          float combinedRipple = (ripple1 + ripple2 + ripple3) * effectiveAmplitude;

          vec2 normal = normalize(uv - center);
          vec2 distortedUV = getCoverUV(uv + normal * combinedRipple, uTexture2Size);

          vec4 distortedImg = texture2D(uTexture2, distortedUV);

          float fadeEdge = smoothstep(maxDist, maxDist * 0.9, dist);
          vec4 rippleResult = mix(newImg, distortedImg, fadeEdge);

          float mask = smoothstep(0.0, 0.3, progress) * (1.0 - smoothstep(0.7, 1.0, progress));
          rippleResult = mix(newImg, rippleResult, mask);

          rippleResult.rgb = mix(rippleResult.rgb, rippleResult.rgb * 1.2, (uColorEnhancement - 1.0) * 0.5);

          float transition = smoothstep(0.0, 1.0, progress);
          return mix(currentImg, rippleResult, transition);
        }

        vec4 plasmaEffect(vec2 uv, float progress) {
          vec4 currentImg = texture2D(uTexture1, getCoverUV(uv, uTexture1Size));
          vec4 newImg = texture2D(uTexture2, getCoverUV(uv, uTexture2Size));

          float effectiveSpeed = uPlasmaSpeed * uSpeedMultiplier;
          float effectiveIntensity = uPlasmaIntensity * uGlobalIntensity;
          float time = progress * 8.0 * effectiveSpeed;

          float plasma1 = sin(uv.x * 10.0 + time) * cos(uv.y * 8.0 + time * 0.7);
          float plasma2 = sin((uv.x + uv.y) * 12.0 + time * 1.3) * cos((uv.x - uv.y) * 15.0 + time * 0.9);
          float plasma3 = sin(length(uv - vec2(0.5)) * 20.0 + time * 1.8);

          float turbulence1 = smoothNoise(uv * 15.0 * uPlasmaTurbulence + vec2(time * 0.5, time * 0.3));
          float turbulence2 = smoothNoise(uv * 25.0 * uPlasmaTurbulence + vec2(time * 0.8, -time * 0.4)) * 0.7;
          float turbulence3 = smoothNoise(uv * 40.0 * uPlasmaTurbulence + vec2(-time * 0.6, time * 0.9)) * 0.4;

          float combinedTurbulence = (turbulence1 + turbulence2 + turbulence3) / 2.1;

          float plasma = (plasma1 + plasma2 + plasma3) * 0.333 + combinedTurbulence * 0.5;
          plasma = sin(plasma * 3.14159);

          float plasmaPhase = smoothstep(0.0, 0.3, progress) * (1.0 - smoothstep(0.7, 1.0, progress));

          vec2 electricField = vec2(
            sin(plasma * 6.28 + time) * 0.02,
            cos(plasma * 4.71 + time * 1.1) * 0.02
          ) * effectiveIntensity * plasmaPhase * uDistortionStrength;

          vec2 flowField1 = vec2(
            smoothNoise(uv * 8.0 + time * 0.4),
            smoothNoise(uv * 8.0 + time * 0.4 + 100.0)
          ) - 0.5;

          vec2 flowField2 = vec2(
            smoothNoise(uv * 16.0 + time * 0.6 + 200.0),
            smoothNoise(uv * 16.0 + time * 0.6 + 300.0)
          ) - 0.5;

          flowField1 *= 0.015 * effectiveIntensity * plasmaPhase * uDistortionStrength;
          flowField2 *= 0.008 * effectiveIntensity * plasmaPhase * uDistortionStrength;

          vec2 totalDistortion = electricField + flowField1 + flowField2;

          vec2 distortedUV1 = getCoverUV(uv + totalDistortion, uTexture1Size);
          vec2 distortedUV2 = getCoverUV(uv + totalDistortion, uTexture2Size);

          vec4 distortedCurrentImg = texture2D(uTexture1, distortedUV1);
          vec4 distortedNewImg = texture2D(uTexture2, distortedUV2);

          float energyMask = abs(plasma) * plasmaPhase * effectiveIntensity;

          vec4 blendedDistorted = mix(distortedCurrentImg, distortedNewImg, progress);

          vec3 energyColor = vec3(0.9, 0.95, 1.0);

          float energyPulse = sin(time * 4.0) * 0.5 + 0.5;
          float finalEnergyIntensity = energyMask * uPlasmaEnergyIntensity * (0.7 + energyPulse * 0.3);

          float contrast = 1.0 + energyMask * uPlasmaContrastBoost;
          vec3 contrastedColor = (blendedDistorted.rgb - 0.5) * contrast + 0.5;

          float saturationBoost = 1.0 + energyMask * 0.4;
          float luminance = dot(contrastedColor, vec3(0.299, 0.587, 0.114));
          vec3 saturatedColor = mix(vec3(luminance), contrastedColor, saturationBoost);

          vec3 glowColor = saturatedColor + energyColor * finalEnergyIntensity;

          float crackle = smoothNoise(uv * 50.0 + time * 2.0);
          crackle = smoothstep(0.85, 1.0, crackle) * energyMask;
          glowColor += vec3(1.0) * crackle * uPlasmaEnergyIntensity * 0.5;

          float brightnessPulse = sin(time * 6.0 + plasma * 10.0) * 0.5 + 0.5;
          glowColor += energyMask * brightnessPulse * uPlasmaEnergyIntensity * 0.2;

          glowColor = mix(glowColor, glowColor * 1.2, (uColorEnhancement - 1.0) * 0.5);

          vec4 plasmaResult = vec4(glowColor, 1.0);

          if (progress > 0.85) {
            float endFade = (progress - 0.85) / 0.15;
            plasmaResult = mix(plasmaResult, newImg, endFade);
          }

          float overallTransition = smoothstep(0.0, 1.0, progress);
          return mix(currentImg, plasmaResult, overallTransition);
        }

        vec4 timeshiftEffect(vec2 uv, float progress) {
          vec2 uv1 = getCoverUV(uv, uTexture1Size);
          vec2 uv2_base = getCoverUV(uv, uTexture2Size);
          vec4 currentImg = texture2D(uTexture1, uv1);
          vec4 newImg = texture2D(uTexture2, uv2_base);

          float effectiveDistortion = uTimeshiftDistortion * uDistortionStrength * uGlobalIntensity;
          float effectiveBlur = uTimeshiftBlur * uGlobalIntensity;
          float effectiveFlow = uTimeshiftFlow * uSpeedMultiplier;
          float effectiveChromatic = uTimeshiftChromatic * uGlobalIntensity;
          float effectiveTurbulence = uTimeshiftTurbulence;

          vec2 center = vec2(0.5, 0.5);
          vec2 p = uv * uResolution;
          vec2 sphereCenter = center * uResolution;

          float maxRadius = length(uResolution) * 0.85;
          float circleRadius = progress * maxRadius;

          float dist = length(p - sphereCenter);
          float normalizedDist = dist / max(circleRadius, 0.001);

          float boundaryWidth = 0.2 * effectiveBlur;
          float inside = smoothstep(circleRadius + circleRadius * boundaryWidth,
                                   circleRadius - circleRadius * boundaryWidth, dist);

          vec4 finalColor = newImg;

          if (inside > 0.01 && inside < 0.99) {
            vec2 fromCenter = uv - center;
            float radius = length(fromCenter);
            vec2 direction = radius > 0.0 ? fromCenter / radius : vec2(0.0);

            float boundaryStrength = smoothstep(0.0, 0.3, inside) * smoothstep(1.0, 0.7, inside);

            float time = progress * 6.28 * effectiveFlow;

            float turb1 = smoothNoise(uv * 12.0 * effectiveTurbulence + time * 0.4);
            float turb2 = smoothNoise(uv * 20.0 * effectiveTurbulence - time * 0.5);
            float turb3 = smoothNoise(uv * 35.0 * effectiveTurbulence + time * 0.7);
            float turb4 = smoothNoise(uv * 55.0 * effectiveTurbulence - time * 0.4);

            vec2 turbulence = vec2(
              (turb1 - 0.5) * 1.2 + (turb2 - 0.5) * 0.8 + (turb3 - 0.5) * 0.4,
              (turb2 - 0.5) * 1.2 + (turb3 - 0.5) * 0.8 + (turb4 - 0.5) * 0.4
            );

            float displacementStrength = 0.18 * effectiveDistortion * boundaryStrength;
            vec2 displacement = turbulence * displacementStrength;

            float radialPull = sin(normalizedDist * 12.0 - time * 2.5) * 0.05 * effectiveDistortion;
            displacement += direction * radialPull * boundaryStrength;

            vec2 perpendicular = vec2(-direction.y, direction.x);
            float swirl = sin(time * 2.5 + normalizedDist * 10.0) * 0.06 * effectiveFlow;
            displacement += perpendicular * swirl * boundaryStrength;

            vec2 distortedUV1 = getCoverUV(uv + displacement, uTexture1Size);
            vec2 distortedUV2 = getCoverUV(uv + displacement, uTexture2Size);

            vec4 distortedOld = texture2D(uTexture1, distortedUV1);
            vec4 distortedNew = texture2D(uTexture2, distortedUV2);

            if (effectiveChromatic > 0.01) {
              float chromaticStr = boundaryStrength * 0.03 * effectiveChromatic;

              vec2 uv1_r = getCoverUV(uv + displacement + direction * chromaticStr * 2.0, uTexture1Size);
              vec2 uv1_b = getCoverUV(uv + displacement - direction * chromaticStr * 1.2, uTexture1Size);
              distortedOld = vec4(
                texture2D(uTexture1, uv1_r).r,
                distortedOld.g,
                texture2D(uTexture1, uv1_b).b,
                1.0
              );

              vec2 uv2_r = getCoverUV(uv + displacement + direction * chromaticStr * 2.0, uTexture2Size);
              vec2 uv2_b = getCoverUV(uv + displacement - direction * chromaticStr * 1.2, uTexture2Size);
              distortedNew = vec4(
                texture2D(uTexture2, uv2_r).r,
                distortedNew.g,
                texture2D(uTexture2, uv2_b).b,
                1.0
              );
            }

            finalColor = mix(distortedOld, distortedNew, inside);

            if (effectiveBlur > 0.5) {
              vec4 blurSample1 = texture2D(uTexture2, getCoverUV(uv + displacement + turbulence * 0.015, uTexture2Size));
              vec4 blurSample2 = texture2D(uTexture2, getCoverUV(uv + displacement - turbulence * 0.015, uTexture2Size));
              vec4 blurSample3 = texture2D(uTexture1, getCoverUV(uv + displacement + vec2(turbulence.y, -turbulence.x) * 0.015, uTexture1Size));

              float blurAmount = boundaryStrength * effectiveBlur * 0.6;
              finalColor = mix(finalColor, (finalColor + blurSample1 + blurSample2 + blurSample3) * 0.25, blurAmount);
            }

          } else if (inside >= 0.99) {
            finalColor = newImg;
          } else {
            finalColor = currentImg;
          }

          finalColor.rgb = mix(finalColor.rgb, finalColor.rgb * 1.2, (uColorEnhancement - 1.0) * 0.5);

          if (progress > 0.95) {
            float endTransition = (progress - 0.95) / 0.05;
            finalColor = mix(finalColor, newImg, endTransition);
          }

          return mix(currentImg, finalColor, smoothstep(0.0, 1.0, progress));
        }

        void main() {
          if (uEffectType == 0) {
            gl_FragColor = glassEffect(vUv, uProgress);
          } else if (uEffectType == 1) {
            gl_FragColor = frostEffect(vUv, uProgress);
          } else if (uEffectType == 2) {
            gl_FragColor = rippleEffect(vUv, uProgress);
          } else if (uEffectType == 3) {
            gl_FragColor = plasmaEffect(vUv, uProgress);
          } else {
            gl_FragColor = timeshiftEffect(vUv, uProgress);
          }
        }
      `;

      const getEffectIndex = (effectName) => {
        const effectMap = {
          glass: 0,
          frost: 1,
          ripple: 2,
          plasma: 3,
          timeshift: 4,
        };
        return effectMap[effectName] || 0;
      };

      const setupPane = () => {
        pane = new Pane({ title: "Visual Effects Controls" });

        const generalFolder = pane.addFolder({ title: "General Settings" });
        generalFolder.addBinding(SLIDER_CONFIG.settings, "globalIntensity", {
          label: "Global Intensity",
          min: 0.1,
          max: 2.0,
          step: 0.1,
        });
        generalFolder.addBinding(SLIDER_CONFIG.settings, "speedMultiplier", {
          label: "Speed Multiplier",
          min: 0.1,
          max: 3.0,
          step: 0.1,
        });
        generalFolder.addBinding(SLIDER_CONFIG.settings, "distortionStrength", {
          label: "Distortion",
          min: 0.1,
          max: 3.0,
          step: 0.1,
        });

        const effectFolder = pane.addFolder({ title: "Effect Selection" });
        effectFolder.addBinding(SLIDER_CONFIG.settings, "currentEffect", {
          label: "Effect Type",
          options: {
            Glass: "glass",
            Frost: "frost",
            Ripple: "ripple",
            Plasma: "plasma",
            Timeshift: "timeshift",
          },
        });

        pane.on("change", () => {
          if (!isApplyingPreset) {
            updateShaderUniforms();
          }
        });

        const paneElement = document.querySelector(".tp-dfwv");
        if (paneElement) {
          paneElement.style.display = "none";
        }
      };

      const updateShaderUniforms = () => {
        if (!shaderMaterial) return;

        const s = SLIDER_CONFIG.settings;
        shaderMaterial.uniforms.uEffectType.value = getEffectIndex(
          s.currentEffect
        );
        shaderMaterial.uniforms.uGlobalIntensity.value = s.globalIntensity;
        shaderMaterial.uniforms.uSpeedMultiplier.value = s.speedMultiplier;
        shaderMaterial.uniforms.uDistortionStrength.value = s.distortionStrength;
        shaderMaterial.uniforms.uColorEnhancement.value = s.colorEnhancement;

        shaderMaterial.uniforms.uGlassRefractionStrength.value =
          s.glassRefractionStrength;
        shaderMaterial.uniforms.uGlassChromaticAberration.value =
          s.glassChromaticAberration;
        shaderMaterial.uniforms.uGlassBubbleClarity.value = s.glassBubbleClarity;
        shaderMaterial.uniforms.uGlassEdgeGlow.value = s.glassEdgeGlow;
        shaderMaterial.uniforms.uGlassLiquidFlow.value = s.glassLiquidFlow;

        shaderMaterial.uniforms.uFrostIntensity.value = s.frostIntensity;
        shaderMaterial.uniforms.uFrostCrystalSize.value = s.frostCrystalSize;
        shaderMaterial.uniforms.uFrostIceCoverage.value = s.frostIceCoverage;
        shaderMaterial.uniforms.uFrostTemperature.value = s.frostTemperature;
        shaderMaterial.uniforms.uFrostTexture.value = s.frostTexture;

        shaderMaterial.uniforms.uRippleFrequency.value = s.rippleFrequency;
        shaderMaterial.uniforms.uRippleAmplitude.value = s.rippleAmplitude;
        shaderMaterial.uniforms.uRippleWaveSpeed.value = s.rippleWaveSpeed;
        shaderMaterial.uniforms.uRippleRippleCount.value = s.rippleRippleCount;
        shaderMaterial.uniforms.uRippleDecay.value = s.rippleDecay;

        shaderMaterial.uniforms.uPlasmaIntensity.value = s.plasmaIntensity;
        shaderMaterial.uniforms.uPlasmaSpeed.value = s.plasmaSpeed;
        shaderMaterial.uniforms.uPlasmaEnergyIntensity.value =
          s.plasmaEnergyIntensity;
        shaderMaterial.uniforms.uPlasmaContrastBoost.value =
          s.plasmaContrastBoost;
        shaderMaterial.uniforms.uPlasmaTurbulence.value = s.plasmaTurbulence;

        shaderMaterial.uniforms.uTimeshiftDistortion.value =
          s.timeshiftDistortion;
        shaderMaterial.uniforms.uTimeshiftBlur.value = s.timeshiftBlur;
        shaderMaterial.uniforms.uTimeshiftFlow.value = s.timeshiftFlow;
        shaderMaterial.uniforms.uTimeshiftChromatic.value = s.timeshiftChromatic;
        shaderMaterial.uniforms.uTimeshiftTurbulence.value =
          s.timeshiftTurbulence;
      };

      const loadTextures = () => {
        return new Promise((resolve) => {
          const textureLoader = new THREE.TextureLoader();
          let loadedCount = 0;

          slides.forEach((slide, index) => {
            textureLoader.load(slide.media, (texture) => {
              texture.minFilter = THREE.LinearFilter;
              texture.magFilter = THREE.LinearFilter;
              slideTextures[index] = texture;
              loadedCount++;

              if (loadedCount === slides.length) {
                texturesLoaded = true;
                resolve();
              }
            });
          });
        });
      };

      const initThreeJS = async () => {
        const canvas = document.querySelector(".webgl-canvas");

        renderer = new THREE.WebGLRenderer({
          canvas,
          antialias: true,
          alpha: false,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        scene = new THREE.Scene();

        camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
        camera.position.z = 1;

        await loadTextures();

        const firstTexture = slideTextures[0];
        const secondTexture = slideTextures[1] || slideTextures[0];

        shaderMaterial = new THREE.ShaderMaterial({
          uniforms: {
            uTexture1: { value: firstTexture },
            uTexture2: { value: secondTexture },
            uProgress: { value: 0 },
            uResolution: {
              value: new THREE.Vector2(window.innerWidth, window.innerHeight),
            },
            uTexture1Size: {
              value: new THREE.Vector2(
                firstTexture.image.width,
                firstTexture.image.height
              ),
            },
            uTexture2Size: {
              value: new THREE.Vector2(
                secondTexture.image.width,
                secondTexture.image.height
              ),
            },
            uEffectType: { value: 0 },
            uGlobalIntensity: { value: 1.0 },
            uSpeedMultiplier: { value: 1.0 },
            uDistortionStrength: { value: 1.0 },
            uColorEnhancement: { value: 1.0 },
            uGlassRefractionStrength: { value: 1.0 },
            uGlassChromaticAberration: { value: 1.0 },
            uGlassBubbleClarity: { value: 1.0 },
            uGlassEdgeGlow: { value: 1.0 },
            uGlassLiquidFlow: { value: 1.0 },
            uFrostIntensity: { value: 1.5 },
            uFrostCrystalSize: { value: 1.0 },
            uFrostIceCoverage: { value: 1.0 },
            uFrostTemperature: { value: 1.0 },
            uFrostTexture: { value: 1.0 },
            uRippleFrequency: { value: 25.0 },
            uRippleAmplitude: { value: 0.08 },
            uRippleWaveSpeed: { value: 1.0 },
            uRippleRippleCount: { value: 1.0 },
            uRippleDecay: { value: 1.0 },
            uPlasmaIntensity: { value: 1.2 },
            uPlasmaSpeed: { value: 0.8 },
            uPlasmaEnergyIntensity: { value: 0.4 },
            uPlasmaContrastBoost: { value: 0.3 },
            uPlasmaTurbulence: { value: 1.0 },
            uTimeshiftDistortion: { value: 1.6 },
            uTimeshiftBlur: { value: 1.5 },
            uTimeshiftFlow: { value: 1.4 },
            uTimeshiftChromatic: { value: 1.5 },
            uTimeshiftTurbulence: { value: 1.4 },
          },
          vertexShader,
          fragmentShader,
        });

        const geometry = new THREE.PlaneGeometry(2, 2);
        const mesh = new THREE.Mesh(geometry, shaderMaterial);
        scene.add(mesh);

        updateShaderUniforms();

        const animate = () => {
          requestAnimationFrame(animate);
          renderer.render(scene, camera);
        };
        animate();
      };

      const createNavigation = () => {
        const nav = document.getElementById("slidesNav");
        nav.innerHTML = "";

        slides.forEach((slide, index) => {
          const item = document.createElement("button");
          item.className = `slide-nav-item ${index === 0 ? "active" : ""}`;
          item.innerHTML = `
            <div class="slide-progress-line">
              <div class="slide-progress-fill" id="progress-${index}"></div>
            </div>
            <span class="slide-nav-title">${slide.title}</span>
          `;
          item.addEventListener("click", () => goToSlide(index));
          nav.appendChild(item);
        });

        document.getElementById("slideTotal").textContent = String(
          slides.length
        ).padStart(2, "0");
      };

      const updateUI = () => {
        document.getElementById("slideNumber").textContent = String(
          currentSlideIndex + 1
        ).padStart(2, "0");

        document.querySelectorAll(".slide-nav-item").forEach((item, index) => {
          item.classList.toggle("active", index === currentSlideIndex);
        });
      };

      const animateProgress = (startTime, duration) => {
        const progressBar = document.getElementById(
          `progress-${currentSlideIndex}`
        );
        if (!progressBar) return;

        const update = () => {
          if (!sliderEnabled) return;

          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);
          progressBar.style.width = `${progress * 100}%`;

          if (progress < 1) {
            progressAnimation = requestAnimationFrame(update);
          }
        };

        progressAnimation = requestAnimationFrame(update);
      };

      const resetProgress = () => {
        if (progressAnimation) {
          cancelAnimationFrame(progressAnimation);
        }

        document.querySelectorAll(".slide-progress-fill").forEach((bar) => {
          bar.style.width = "0%";
        });
      };

      const goToSlide = (index) => {
        if (isTransitioning || index === currentSlideIndex || !texturesLoaded)
          return;

        isTransitioning = true;

        if (autoSlideTimer) {
          clearTimeout(autoSlideTimer);
        }
        resetProgress();

        const fromIndex = currentSlideIndex;
        const toIndex = index;

        shaderMaterial.uniforms.uTexture1.value = slideTextures[fromIndex];
        shaderMaterial.uniforms.uTexture2.value = slideTextures[toIndex];

        const fromTexture = slideTextures[fromIndex];
        const toTexture = slideTextures[toIndex];
        shaderMaterial.uniforms.uTexture1Size.value.set(
          fromTexture.image.width,
          fromTexture.image.height
        );
        shaderMaterial.uniforms.uTexture2Size.value.set(
          toTexture.image.width,
          toTexture.image.height
        );

        shaderMaterial.uniforms.uProgress.value = 0;

        currentSlideIndex = toIndex;
        updateUI();

        const startTime = performance.now();
        const duration = TRANSITION_DURATION() * 1000;

        const animateTransition = (currentTime) => {
          const elapsed = currentTime - startTime;
          const progress = Math.min(elapsed / duration, 1);

          const eased =
            progress < 0.5
              ? 4 * progress * progress * progress
              : 1 - Math.pow(-2 * progress + 2, 3) / 2;

          shaderMaterial.uniforms.uProgress.value = eased;

          if (progress < 1) {
            requestAnimationFrame(animateTransition);
          } else {
            shaderMaterial.uniforms.uProgress.value = 1;
            isTransitioning = false;

            shaderMaterial.uniforms.uTexture1.value = slideTextures[toIndex];
            shaderMaterial.uniforms.uProgress.value = 0;

            if (sliderEnabled) {
              startAutoSlide();
            }
          }
        };

        requestAnimationFrame(animateTransition);
      };

      const nextSlide = () => {
        const next = (currentSlideIndex + 1) % slides.length;
        goToSlide(next);
      };

      const prevSlide = () => {
        const prev =
          (currentSlideIndex - 1 + slides.length) % slides.length;
        goToSlide(prev);
      };

      const startAutoSlide = () => {
        if (autoSlideTimer) {
          clearTimeout(autoSlideTimer);
        }
        resetProgress();

        const duration = SLIDE_DURATION();
        animateProgress(Date.now(), duration);

        autoSlideTimer = setTimeout(() => {
          if (sliderEnabled) {
            nextSlide();
          }
        }, duration);
      };

      const handleResize = () => {
        if (!renderer) return;

        renderer.setSize(window.innerWidth, window.innerHeight);
        shaderMaterial.uniforms.uResolution.value.set(
          window.innerWidth,
          window.innerHeight
        );
      };

      const handleKeyboard = (e) => {
        if (e.key === "ArrowRight" || e.key === " ") {
          e.preventDefault();
          nextSlide();
        } else if (e.key === "ArrowLeft") {
          e.preventDefault();
          prevSlide();
        } else if (e.key === "h" || e.key === "H") {
          const paneElement = document.querySelector(".tp-dfwv");
          if (paneElement) {
            paneElement.style.display =
              paneElement.style.display === "none" ? "block" : "none";
          }
        }
      };

      const handleTouch = (e) => {
        if (e.type === "touchstart") {
          touchStartX = e.changedTouches[0].screenX;
        } else if (e.type === "touchend") {
          touchEndX = e.changedTouches[0].screenX;
          const diff = touchStartX - touchEndX;
          if (Math.abs(diff) > 50) {
            if (diff > 0) {
              nextSlide();
            } else {
              prevSlide();
            }
          }
        }
      };

      const init = async () => {
        createNavigation();
        await initThreeJS();
        setupPane();

        window.addEventListener("resize", handleResize);
        window.addEventListener("keydown", handleKeyboard);
        document
          .querySelector(".slider-wrapper")
          .addEventListener("click", nextSlide);
        document.addEventListener("touchstart", handleTouch, { passive: true });
        document.addEventListener("touchend", handleTouch, { passive: true });

        setTimeout(() => {
          sliderEnabled = true;
          startAutoSlide();
        }, 4000);
      };

      init();
    </script>
  </body>
</html>
